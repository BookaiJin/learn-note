没有什么太强的模式的要求，按需使用，在分析实现需求的时候自然会使用相应的模式

书中所讲的只是一些例子

操作的互斥线程，数据

### 1.临界区

sync加锁，只有一个线程可以执行，保证临界区的安全

### 2.immutable

不可变对象的线程安全，高效率

### 3.等待准备好

服务器、客户端socket处理，强调的是消费者要等待生产者

```java
public class RequestQueue{
    privete final Queue<Request> queue = new LinkedList<>();
    
    public synchronized Request getRequest(){
        while(queue.peek()==null){
            try{
	             wait();
            } catch (InterruptedException e){
                
            }
        }
        return queue.remove();
    }
    
    public synchronized void putRequest(Request request){
        queue.offer(request);
        notifyAll();
    }
}
```

ClientThread调用putRequest

ServerThread调用getRequest

无限准备，取得时候如果没有就等待，内存没有约束到

### 4.balking

同时修改，标志位判断，如果修改过就跳过

```java
public class Data(){
    private volatile boolean changed = false;
    private String content;
    
    public synchronized void change(String content){
        this.content = content;
        this.changed = true;
    }
    
    public synchronized void save(){
        if(!changed){
            return;
        }
        doSave();
        this.changed = false;
    }
}
```



```java
public class ChangeThread{
    public void changeContent(Data data, String content){
        data.change(content);
        data.save();
    }
}
```



```java
public class SaveThread{
    private Data data;
    
    public void saveContent(){
        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(2
        executorService.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                data.save();
            }
        }, 1,1, TimeUnit.MINUTES);
    }
}
```



### 5.生产者消费者

channel、producer、consumer

channel中维护了生产对象的序列，序列的实现方式

1. 队列：先进先出
2. 栈：后进先出
3. 优先队列：按照优先级

守护条件

队列满之前，生产者向序列中放

队列空之前，消费者从序列中拿

### 6.读写锁

读写、写写互斥

### 7.Thread per message

懒汉式，接收请求后创建线程

```sequence
participant client
participant server
participant handler
client->server:request
server->handler:create thread handle
server->client:over
handler->handler:do it
```





server创建线程的方法：

1. 匿名内部类Thread.start
2. 匿名内部类Runnable由thread启动执行
3. 较优解:Executor传入server来进行线程创建和任务执行；ThreadFactory作为线程创建的入口，创建统一的线程，接收参数Runnable来执行
4. 这样，一个ExecuteService就生成了

### 8.Worker Thread

多条工作线程的生产者、消费者模型

client生产，相当于producer

worker执行，相当于consumer

Request数据，相当于data

Channel管理Request队列

饿汉式，提前生成多个worker，轮询等待Channel中的任务，任务队列为空时wait，有任务时notifyAll

实际例子：ThreadPool

Swing EDT 事件分发线程只有一个相当于Worker线程只有一个，接收事件之后，生成新的线程去处理事件的action操作