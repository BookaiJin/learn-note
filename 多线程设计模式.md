没有什么太强的模式的要求，按需使用，在分析实现需求的时候自然会使用相应的模式

书中所讲的只是一些例子

操作的互斥线程，数据

### 1.临界区

如何保证某段代码是线程安全的，基本的临界区介绍

sync加锁，只有一个线程可以执行，保证临界区的安全

### 2.immutable

不可变对象的线程安全，高效率

### 3.等待准备好

服务器、客户端socket处理，强调的是消费者要等待生产者

```java
public class RequestQueue{
    privete final Queue<Request> queue = new LinkedList<>();
    
    public synchronized Request getRequest(){
        while(queue.peek()==null){
            try{
	             wait();
            } catch (InterruptedException e){
                
            }
        }
        return queue.remove();
    }
    
    public synchronized void putRequest(Request request){
        queue.offer(request);
        notifyAll();
    }
}
```

ClientThread调用putRequest

ServerThread调用getRequest

无限准备，取得时候如果没有就等待，内存没有约束到

### 4.balking

同时修改，标志位判断，如果修改过就跳过

```java
public class Data(){
    private volatile boolean changed = false;
    private String content;
    
    public synchronized void change(String content){
        this.content = content;
        this.changed = true;
    }
    
    public synchronized void save(){
        if(!changed){
            return;
        }
        doSave();
        this.changed = false;
    }
}
```



```java
public class ChangeThread{
    public void changeContent(Data data, String content){
        data.change(content);
        data.save();
    }
}
```



```java
public class SaveThread{
    private Data data;
    
    public void saveContent(){
        ScheduledExecutorService executorService = Executors.newScheduledThreadPool(2
        executorService.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                data.save();
            }
        }, 1,1, TimeUnit.MINUTES);
    }
}
```



### 5.生产者消费者

channel、producer、consumer

channel中维护了生产对象的序列，序列的实现方式

1. 队列：先进先出
2. 栈：后进先出
3. 优先队列：按照优先级

守护条件

队列满之前，生产者向序列中放

队列空之前，消费者从序列中拿

### 6.读写锁

读写、写写互斥

### 7.Thread per message

懒汉式，接收请求后创建线程

```sequence
participant client
participant server
participant handler
client->server:request
server->handler:create thread handle
server->client:over
handler->handler:do it
```





server创建线程的方法：

1. 匿名内部类Thread.start
2. 匿名内部类Runnable由thread启动执行
3. 较优解:Executor传入server来进行线程创建和任务执行；ThreadFactory作为线程创建的入口，创建统一的线程，接收参数Runnable来执行
4. 这样，一个ExecuteService就生成了

### 8.Worker Thread

多条工作线程的生产者、消费者模型

client生产，相当于producer

worker执行，相当于consumer

Request数据，相当于data

Channel管理Request队列

饿汉式，提前生成多个worker，轮询等待Channel中的任务，任务队列为空时wait，有任务时notifyAll

实际例子：ThreadPool

Swing EDT 事件分发线程只有一个相当于Worker线程只有一个，接收事件之后，生成新的线程去处理事件的action操作

### 10.Two phase terminal

分段执行：先执行操作，再响应中止

就是我们常见的安全结束线程

所有想要中止的计算逻辑都要保证操作的可响应中断性

注：

1. 不能只判断标记位，处于wait、sleep状态的线程判断不了标志位，需要响应线程中断信号interrupt；
2. 只响应interrupt也不行，如果有的操作捕获了中止异常，但是不做操作，就违背设计的初衷，我们中断信号发送的目的就达不到了；
3. 在长任务执行前执行中断状态的检查；这点永洪做的不错，他们的ThreadPoolWithChecker在从任务队列获取任务之后，会先判断任务的状态，不需要中断的时候再创建线程去执行；
4. 可以结合join和alive来判断等待线程是否运行结束；
5. 执行的任务Runnable中，保存检测的中断标志位，从任务队列获取任务执行

ExecutorService的shutdown方法，判断对线程池里的线程是否发送了中止信号

重要：响应中止之后的整理工作

### 11.Thread-Specific Storage

jdk中的ThreadLocal

log

ThreadLocal的实例就是一个储物间，每条线程不会都背着储物柜行动

看下ThreadLocal的源码

```java
class Log{
    //所有调用了set的线程，都是再往这个集合里放 调用线程id-对象 的键值对
    ThreadLocal<ThreadLog> theadLogCollection = new ThreadLocal<>();
    
    ThreadLog getLog(){
        //注意，这一步拿到的是对应线程中保存的ThreadLog对象
        ThreadLog log = threadLogCollection.get();
        
        if(log == null){
            log = new ThreadLog(Thread.currentThread.getName() + "-" + "-log.txt");
            threadLogCollection.set(log);
        }
        
        return log;
    }
}
```

咋样，看着眼熟不，Calculator

调用了Calculator保存对象的线程，后续需要的时候都会从Calculator里面直接拿

![image](image-20210609232529739.png)

看下ThreadLocal怎么实现的：

![image-20210609233103587](image-20210609233103587.png)

里面有个map，key就是currentThread value就是你存的T，所以当前线程直接调用ThreadLocal#get()直接是把当前线程做key去搜索了

